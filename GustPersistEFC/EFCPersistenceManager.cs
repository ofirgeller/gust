using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.Common;

using System.Linq;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

using Gust.Core;
using Gust.Persist;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ValueGeneration;
using Microsoft.EntityFrameworkCore.Extensions;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Update;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using System.ComponentModel.DataAnnotations;

namespace Gust.PersistEFC
{

    public interface IEFContextProvider<T> where T : DbContext, new()
    {
        T Context { get; }
    }

    public class EFPersistenceManager<T> : PersistenceManager, IEFContextProvider<T> where T : DbContext, new()
    {
        T _context;
        public T Context
        {
            get
            {
                if (_context == null)
                {
                    _context = CreateContext();
                }
                return _context;
            }
        }

        public bool OwnsConnection { get; }

        public EFPersistenceManager() { }

        public EFPersistenceManager(T context, bool ownsConnection = true)
        {
            _context = context;
            OwnsConnection = ownsConnection;
        }

        protected virtual T CreateContext()
        {
            return new T();
        }

        /// <summary>Gets the EntityConnection from the ObjectContext.</summary>
        public DbConnection EntityConnection => (DbConnection)GetDbConnection();

        /// <summary>Opens the DbConnection used by the Context.</summary>
        protected override void OpenDbConnection()
        {
            var ec = Context.Database.GetDbConnection();
            if (ec.State == ConnectionState.Closed)
            {
                ec.Open();
            }
        }

        protected override void CloseDbConnection()
        {
            if (OwnsConnection)
            {
                var ec = _context?.Database.GetDbConnection();
                ec?.Close();
                ec?.Dispose();
            }
        }

        #region Base implementation overrides

        public override IDbConnection GetDbConnection()
        {
            return Context.Database.GetDbConnection();
        }

        /// <summary>
        /// The mission here is to get this function to return the same metadata that we get from Entity Framework 6
        /// </summary>
        protected override string BuildJsonMetadata()
        {
            var json = GetMetadataFromDbContext(Context);
            return json;
        }

        protected override EntityInfo CreateEntityInfo()
        {
            return new EFEntityInfo();
        }

        public override object[] GetKeyValues(EntityInfo entityInfo)
        {
            return GetKeyValues(entityInfo.Entity);
        }

        public object[] GetKeyValues(object entity)
        {
            var entityType = EntityTypeFromObject(entity);
            var key = entityType.FindPrimaryKey();
            var keyValues = key.Properties.Select(p => p.PropertyInfo.GetValue(entity)).ToArray();
            return keyValues;
        }


        /// TODO: #Ofir add validation error read and turn into an exception
        /// https://github.com/aspnet/EntityFrameworkCore/issues/4434
        //public override int SaveChanges()
        //{
        //    var entities = (from entry in ChangeTracker.Entries()
        //                    where entry.State == EntityState.Modified || entry.State == EntityState.Added
        //                    select entry.Entity);

        //    var validationResults = new List<ValidationResult>();
        //    foreach (var entity in entities)
        //    {
        //        if (!Validator.TryValidateObject(entity, new ValidationContext(entity), validationResults))
        //        {
        //            // throw new ValidationException() or do whatever you want
        //        }
        //    }
        //    return base.SaveChanges();
        //}


        /// <summary>
        ///See Todo above 
        /// </summary>
        /// <param name="saveWorkState"></param>
        protected override void SaveChangesCore(SaveWorkState saveWorkState)
        {
            var saveMap = saveWorkState.SaveMap;
            var deletedEntities = ProcessSaves(saveMap);

            if (deletedEntities.Any())
            {
                ProcessAllDeleted(deletedEntities);
            }

            ProcessAutogeneratedKeys(saveWorkState.EntitiesWithAutoGeneratedKeys);

            int count;
            try
            {
                if (Context is DbContext)
                {
                    count = ((DbContext)(object)Context).SaveChanges();
                }
                else
                {
                    count = Context.SaveChanges(acceptAllChangesOnSuccess: true);
                }
            }
            //catch (ValidationException e)
            //{
            //    var entityErrors = new List<EntityError>();
            //    foreach (var eve in e.EntityValidationErrors)
            //    {
            //        var entity = eve.Entry.Entity;
            //        var entityTypeName = entity.GetType().FullName;
            //        Object[] keyValues;
            //        var key = ObjectContext.ObjectStateManager.GetObjectStateEntry(entity).EntityKey;
            //        if (key.EntityKeyValues != null)
            //        {
            //            keyValues = key.EntityKeyValues.Select(km => km.Value).ToArray();
            //        }
            //        else
            //        {
            //            var entityInfo = saveWorkState.EntitiesWithAutoGeneratedKeys.FirstOrDefault(ei => ei.Entity == entity);
            //            if (entityInfo != null)
            //            {
            //                keyValues = new Object[] { entityInfo.AutoGeneratedKey.TempValue };
            //            }
            //            else
            //            {
            //                // how can this happen?
            //                keyValues = null;
            //            }
            //        }
            //        foreach (var ve in eve.ValidationErrors)
            //        {
            //            var entityError = new EntityError()
            //            {
            //                EntityTypeName = entityTypeName,
            //                KeyValues = keyValues,
            //                ErrorMessage = ve.ErrorMessage,
            //                PropertyName = ve.PropertyName
            //            };
            //            entityErrors.Add(entityError);
            //        }

            //    }
            //    saveWorkState.EntityErrors = entityErrors;

            //}
            catch (DataException e)
            {
                var nextException = (Exception)e;
                while (nextException.InnerException != null)
                {
                    nextException = nextException.InnerException;
                }
                if (nextException == e)
                {
                    throw;
                }
                else
                {
                    //create a new exception that contains the toplevel exception
                    //but has the innermost exception message propogated to the top.
                    //For EF exceptions, this is often the most 'relevant' message.
                    throw new Exception(nextException.Message, e);
                }
            }
            catch (Exception)
            {
                throw;
            }

            saveWorkState.KeyMappings = UpdateAutoGeneratedKeys(saveWorkState.EntitiesWithAutoGeneratedKeys);
        }
        #endregion

        #region Save related methods

        List<EFEntityInfo> ProcessSaves(Dictionary<Type, List<EntityInfo>> saveMap)
        {
            var deletedEntities = new List<EFEntityInfo>();
            foreach (var kvp in saveMap.Where(g => g.Value?.Count > 0))
            {
                var entitySetName = GetEntitySetName(kvp.Key);
                foreach (EFEntityInfo entityInfo in kvp.Value)
                {
                    entityInfo.EntitySetName = entitySetName;
                    ProcessEntity(entityInfo);
                    if (entityInfo.EntityState == Persist.EntityState.Deleted)
                    {
                        deletedEntities.Add(entityInfo);
                    }
                }
            }
            return deletedEntities;
        }

        void ProcessAllDeleted(List<EFEntityInfo> deletedEntities)
        {
            deletedEntities.ForEach(entityInfo =>
            {
                RestoreOriginal(entityInfo);
                var entry = GetOrAddEntityEntry(entityInfo);
                entry.State = Microsoft.EntityFrameworkCore.EntityState.Deleted;
                if (entityInfo.EfcEntityEntry == entry)
                {
                    throw new Exception("we do not need this code");
                }
                entityInfo.EfcEntityEntry = entry;
            });
        }

        void ProcessAutogeneratedKeys(List<EntityInfo> entitiesWithAutoGeneratedKeys)
        {
            var tempKeys = entitiesWithAutoGeneratedKeys.Cast<EFEntityInfo>().Where(
              entityInfo => entityInfo.AutoGeneratedKey.AutoGeneratedKeyType == AutoGeneratedKeyType.KeyGenerator)
              .Select(ei => new TempKeyInfo(ei))
              .ToList();

            if (tempKeys.Count == 0)
            {
                return;
            }

            if (KeyGenerator == null)
            {
                KeyGenerator = GetKeyGenerator();
            }

            KeyGenerator.UpdateKeys(tempKeys);
            tempKeys.ForEach(tki =>
            {
                // Clever hack - next 3 lines cause all entities related to tki.Entity to have 
                // their relationships updated. So all related entities for each tki are updated.
                // Basically we set the entity to look like a preexisting entity by setting its
                // entityState to unchanged.  This is what fixes up the relations, then we set it back to added
                // Now when we update the pk - all fks will get changed as well.  Note that the fk change will only
                // occur during the save.
                var entry = GetEntityEntry(tki.Entity);
                entry.State = Microsoft.EntityFrameworkCore.EntityState.Unchanged;
                entry.State = Microsoft.EntityFrameworkCore.EntityState.Added;

                /// This original code has todo with the bug. the bug probable does not exist in EFC but 
                /// I keep it until we can prove that
                //entry.ChangeState(System.Data.Entity.EntityState.Unchanged);
                //entry.ChangeState(System.Data.Entity.EntityState.Added);
                var val = ConvertValue(tki.RealValue, tki.Property.PropertyType);
                tki.Property.SetValue(tki.Entity, val, null);
            });
        }

        IKeyGenerator GetKeyGenerator()
        {
            var generatorType = KeyGeneratorType.Value;
            return new NumericKeyGenerator(EntityConnection);
        }

        EntityInfo ProcessEntity(EFEntityInfo entityInfo)
        {
            EntityEntry entityEntry;
            if (entityInfo.EntityState == Persist.EntityState.Modified)
            {
                entityEntry = HandleModified(entityInfo);
            }
            else if (entityInfo.EntityState == Persist.EntityState.Added)
            {
                entityEntry = HandleAdded(entityInfo);
            }
            else if (entityInfo.EntityState == Persist.EntityState.Deleted)
            {
                /// For 1st pass this does NOTHING 
                entityEntry = HandleDeletedPart1(entityInfo);
            }
            else
            {
                /// Needed for many to many to get both ends into the Context
                entityEntry = HandleUnchanged(entityInfo);
            }
            entityInfo.EfcEntityEntry = entityEntry;
            return entityInfo;
        }

        EntityEntry HandleAdded(EFEntityInfo entityInfo)
        {
            var entry = AddEntityEntry(entityInfo);
            if (entityInfo.AutoGeneratedKey != null)
            {
                entityInfo.AutoGeneratedKey.TempValue = GetOsePropertyValue(entry, entityInfo.AutoGeneratedKey.PropertyName);
            }
            entry.State = Microsoft.EntityFrameworkCore.EntityState.Added;
            return entry;
        }

        EntityEntry HandleModified(EFEntityInfo entityInfo)
        {
            var entry = AddEntityEntry(entityInfo);
            // EntityState will be changed to modified during the update from the OriginalValuesMap
            // Do NOT change this to EntityState.Modified because this will cause the entire record to update.

            entry.State = Microsoft.EntityFrameworkCore.EntityState.Unchanged;

            // updating the original values is necessary under certain conditions when we change a foreign key field
            // because the before value is used to determine ordering.
            UpdateOriginalValues(entry, entityInfo);

            if (entry.State != Microsoft.EntityFrameworkCore.EntityState.Modified || entityInfo.ForceUpdate)
            {
                // _originalValusMap can be null if we mark entity.SetModified but don't actually change anything.
                // entry.ChangeState(System.Data.Entity.EntityState.Modified);
                // Ofir: I really don't get this logic
                entry.State = Microsoft.EntityFrameworkCore.EntityState.Modified;
            }
            return entry;
        }

        EntityEntry HandleUnchanged(EFEntityInfo entityInfo)
        {
            var entry = AddEntityEntry(entityInfo);
            entry.State = Microsoft.EntityFrameworkCore.EntityState.Unchanged;
            return entry;
        }

        EntityEntry HandleDeletedPart1(EntityInfo entityInfo)
        {
            return null;
        }

        IEntityType EntityTypeFromType(Type type)
        {
            return Context.Model.FindEntityType(type);
        }

        IEntityType EntityTypeFromObject(object entity)
        {
            return Context.Model.FindEntityType(entity.GetType());
        }

        EntityInfo RestoreOriginal(EntityInfo entityInfo)
        {
            // fk's can get cleared depending on the order in which deletions occur -
            // EF needs the original values of these fk's under certain circumstances - ( not sure entirely what these are). 
            // so we restore the original fk values right before we attach the entity 
            // shouldn't be any side effects because we delete it immediately after.
            // ??? Do concurrency values also need to be restored in some cases 
            // This method restores more than it actually needs to because we don't
            // have metadata easily avail here, but usually a deleted entity will
            // not have much in the way of OriginalValues.
            if (entityInfo.OriginalValuesMap == null || entityInfo.OriginalValuesMap.Keys.Count == 0)
            {
                return entityInfo;
            }
            var entity = entityInfo.Entity;

            var type = entity.GetType();
            var entityType = EntityTypeFromObject(entity);

            var keyPropertyNames = entityType.FindPrimaryKey().Properties.Select(i => i.Name).ToList();
            var originalValues = entityInfo.OriginalValuesMap.ToList();
            for (var i = 0; i < originalValues.Count; i++)
            {
                var originalValue = originalValues[i];
                var propertyName = originalValue.Key;

                /// Ignore properties that are key
                if (keyPropertyNames.Contains(propertyName))
                {
                    continue;
                }

                var pi = entityType.GetProperty(propertyName);

                /// unmapped properties should be ignored.
                if (pi == null)
                {
                    continue;
                }

                var nnPropType = TypeFns.GetNonNullableType(pi.ClrType);

                // presumption here is that only a predefined type could be a fk or concurrency property
                if (TypeFns.IsPredefinedType(nnPropType))
                {
                    SetPropertyValue(entity, propertyName, originalValue.Value);
                }
            }

            return entityInfo;
        }

        /// <summary>
        /// Not too sure whats happening here.
        /// my guess is that getting the entity state on theser to be the same as the client we apply the current values
        /// from the client but first need to make the original values be the original values from the perspective of 
        /// EF and make EF understand that the modification happened. 
        /// It also seems to me that given the EFC API this can be done in a simpler way. but I sould be carefull not to lose
        /// any smart functionality that avoids bugs in the original code.
        /// </summary>
        static void UpdateOriginalValues(EntityEntry entry, EntityInfo entityInfo)
        {
            var originalValuesMap = entityInfo.OriginalValuesMap;
            if (originalValuesMap == null || originalValuesMap.Keys.Count == 0)
            {
                return;
            }

            /// Original code:
            /// var originalValuesRecord = entry.GetUpdatableOriginalValues();
            var originalValuesRecord = entry.OriginalValues;

            originalValuesMap.ToList().ForEach(kvp =>
            {
                var propertyName = kvp.Key;
                var originalValue = kvp.Value;

                try
                {
                    var member = entry.Member(propertyName);

                    /// Maybe not needed? we are supposed to actualy set the value and that should make the field as modified
                    member.IsModified = true;

                    /// Original code: 
                    //entry.SetModifiedProperty(propertyName);

                    if (originalValue is JObject)
                    {
                        // only really need to perform updating original values on key properties
                        // and a complex object cannot be a key.
                    }
                    else
                    {
                        /// 2017/11/9: Column ordering is not yet supported in EFC
                        /// I'm not sure if we need it as it seems we can access the meta data without it
                        //var ordinal = originalValuesRecord.GetOrdinal(propertyName);
                        //var fieldType = originalValuesRecord.GetFieldType(ordinal);

                        var fieldType = member.Metadata.ClrType;

                        var originalValueConverted = ConvertValue(originalValue, fieldType);

                        if (originalValueConverted == null)
                        {
                            // bug - hack because of bug in EF - see 
                            //// http://social.msdn.microsoft.com/Forums/nl/adodotnetentityframework/thread/cba1c425-bf82-4182-8dfb-f8da0572e5da
                            //var temp = entry.CurrentValues[ordinal];
                            //entry.CurrentValues.SetDBNull(ordinal);
                            //entry.ApplyOriginalValues(entry.Entity);
                            //entry.CurrentValues.SetValue(ordinal, temp);
                        }
                        else
                        {
                            //originalValuesRecord.SetValue(ordinal, originalValueConverted);
                        }
                    }
                }
                catch (Exception e)
                {
                    if (e.Message.Contains(" part of the entity's key"))
                    {
                        throw;
                    }
                    else
                    {
                        // this can happen for "custom" data entity properties.
                    }
                }
            });

        }

        List<KeyMapping> UpdateAutoGeneratedKeys(List<EntityInfo> entitiesWithAutoGeneratedKeys)
        {
            // where clause is necessary in case the Entities were suppressed in the beforeSave event.
            var keyMappings = entitiesWithAutoGeneratedKeys.Cast<EFEntityInfo>()
              .Where(entityInfo => entityInfo.EfcEntityEntry != null)
              .Select(entityInfo =>
              {
                  var autoGeneratedKey = entityInfo.AutoGeneratedKey;
                  if (autoGeneratedKey.AutoGeneratedKeyType == AutoGeneratedKeyType.Identity)
                  {
                      autoGeneratedKey.RealValue = GetOsePropertyValue(entityInfo.EfcEntityEntry, autoGeneratedKey.PropertyName);
                  }
                  return new KeyMapping()
                  {
                      EntityTypeName = entityInfo.Entity.GetType().FullName,
                      TempValue = autoGeneratedKey.TempValue,
                      RealValue = autoGeneratedKey.RealValue
                  };
              });
            return keyMappings.ToList();
        }

        object GetOsePropertyValue(EntityEntry entityEntry, string propertyName)
        {
            var entityType = EntityTypeFromObject(entityEntry.Entity);
            var property = entityType.GetProperty(propertyName);
            var valueType = property.ClrType;

            if (valueType == typeof(string))
            {
                var value = entityEntry.CurrentValues.GetValue<object>(propertyName);
                return value;
            }

            if (valueType == typeof(int))
            {
                var value = entityEntry.CurrentValues.GetValue<int>(propertyName);
                return value as object;
            }

            if (valueType == typeof(long))
            {
                var value = entityEntry.CurrentValues.GetValue<long>(propertyName);
                return value as object;
            }

            if (valueType == typeof(Guid))
            {
                var value = entityEntry.CurrentValues.GetValue<Guid>(propertyName);
                return value as object;
            }

            throw new Exception("Unexpected value type");

            //var currentValues = ose.CurrentValues;
            //var ix = currentValues.GetOrdinal(propertyName);
            //return currentValues[ix];
        }

        void SetOsePropertyValue(EntityEntry ose, string propertyName, object value)
        {
            ose.CurrentValues.SetValues(new Dictionary<string, object> { { propertyName, value } });

            //var currentValues = ose.CurrentValues;
            //var ix = currentValues.GetOrdinal(propertyName);
            //currentValues.SetValue(ix, value);
        }

        void SetPropertyValue(Object entity, String propertyName, Object value)
        {
            var propInfo = entity.GetType().GetProperty(propertyName,
                                                        BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            // exit if unmapped property.
            if (propInfo == null)
            {
                return;
            }

            if (propInfo.CanWrite)
            {
                var val = ConvertValue(value, propInfo.PropertyType);
                propInfo.SetValue(entity, val, null);
            }
            else
            {
                throw new Exception(String.Format("Unable to write to property '{0}' on type: '{1}'", propertyName,
                                                  entity.GetType()));
            }
        }

        static Object ConvertValue(Object val, Type toType)
        {
            Object result;
            if (val == null)
            {
                return val;
            }

            if (toType == val.GetType())
            {
                return val;
            }

            var nnToType = TypeFns.GetNonNullableType(toType);
            if (typeof(IConvertible).IsAssignableFrom(nnToType))
            {
                result = Convert.ChangeType(val, nnToType, System.Threading.Thread.CurrentThread.CurrentCulture);
            }
            else if (val is JObject)
            {
                var serializer = new JsonSerializer();
                result = serializer.Deserialize(new JTokenReader((JObject)val), toType);
            }
            else
            {
                // Guids fail above - try this
                var typeConverter = TypeDescriptor.GetConverter(toType);
                if (typeConverter.CanConvertFrom(val.GetType()))
                {
                    result = typeConverter.ConvertFrom(val);
                }
                else if (val is DateTime && toType == typeof(DateTimeOffset))
                {
                    // handle case where JSON deserializes to DateTime, but toType is DateTimeOffset.  DateTimeOffsetConverter doesn't work!
                    result = new DateTimeOffset((DateTime)val);
                }
                else
                {
                    result = val;
                }
            }
            return result;
        }

        EntityEntry GetOrAddEntityEntry(EFEntityInfo entityInfo)
        {
            var entry = Context.Entry(entityInfo.Entity);
            if (entry.State != Microsoft.EntityFrameworkCore.EntityState.Detached)
            {
                return entry;
            }

            return AddEntityEntry(entityInfo);
        }

        EntityEntry AddEntityEntry(EFEntityInfo entityInfo)
        {
            var entityEntry = GetEntityEntry(entityInfo.Entity, false);
            if (entityEntry.State != Microsoft.EntityFrameworkCore.EntityState.Detached)
            {
                return entityEntry;
            }
            entityEntry.State = Microsoft.EntityFrameworkCore.EntityState.Unchanged;

            // I don't get this commnet: Attach has lots of side effect - add has far fewer.
            //return GetEntityEntry(entityInfo);

            return entityEntry;
        }

        EntityEntry AttachEntityEntry(EFEntityInfo entityInfo)
        {
            var entry = Context.Entry(entityInfo.Entity);
            entry.State = Microsoft.EntityFrameworkCore.EntityState.Unchanged;
            return entry;

            /// Ofir: This comment again?:
            ///Attach has lots of side effect - add has far fewer.
            //return GetEntityEntry(entityInfo);
        }

        EntityEntry GetEntityEntry(EFEntityInfo entityInfo)
        {
            return GetEntityEntry(entityInfo.Entity);
        }

        EntityEntry GetEntityEntry(Object entity, bool errorIfNotFound = true)
        {
            var entityEntry = Context.Entry(entity);
            if (entityEntry.State == Microsoft.EntityFrameworkCore.EntityState.Detached && errorIfNotFound)
            {
                throw new Exception("Expected entity to be atteched to the data context but it was not: " + entity);
            }
            return entityEntry;
        }

        #endregion

        static string GetMetadataFromDbContext(DbContext context)
        {
            return "fakemetadata";
        }

        public string GetEntitySetName(Type clrTypeOfTheEntity)
        {
            var entityType = EntityTypeFromType(clrTypeOfTheEntity);

            /// Ofir: I'm not sure if this is even needed. if it is in most cases the set name can be
            /// derived from the table name. in cases where it is not we will have to add code to 
            /// query the context and get the set name:
            /// The set name seems to be the property name  of the dbcontext 
            /// that contains the DBset of the entitites  
            var tableName = entityType.Relational().TableName;

            return tableName;
        }
    }

    public class EFEntityInfo : EntityInfo
    {
        internal EFEntityInfo()
        {
        }

        internal string EntitySetName;
        internal EntityEntry EfcEntityEntry;
    }

    public class EFEntityError : EntityError
    {
        public EFEntityError(EntityInfo entityInfo, String errorName, String errorMessage, String propertyName)
        {
            if (entityInfo != null)
            {
                EntityTypeName = entityInfo.Entity.GetType().FullName;
                KeyValues = GetKeyValues(entityInfo);
            }
            ErrorName = errorName;
            ErrorMessage = errorMessage;
            PropertyName = propertyName;
        }

        Object[] GetKeyValues(EntityInfo entityInfo)
        {
            return entityInfo.ContextProvider.GetKeyValues(entityInfo);
        }
    }
}