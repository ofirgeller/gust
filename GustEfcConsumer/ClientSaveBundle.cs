using Gust;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using System.Collections.Generic;

namespace GustEfcConsumer
{
    /// <summary>
    /// The javascript client sends data in the form of a save bundle. this class allows to generate
    /// json that looks the same from strongly typed entites
    /// </summary>
    public class ClientSaveBundle
    {
        JsonSerializer JsonSerializer;
        List<EntityAspect> EntityAspects { get; set; } = new List<EntityAspect>();
        SaveOptions SaveOptions { get; set; } = new SaveOptions { Tag = "empty" };

        public ClientSaveBundle(bool pascalCase = false)
        {
            JsonSerializer = new JsonSerializer { ReferenceLoopHandling = ReferenceLoopHandling.Ignore };

            if (!pascalCase)
            {
                JsonSerializer.ContractResolver = new CamelCasePropertyNamesContractResolver();
            }
        }

        public void AddEntity(EntityAspect entityAspect)
        {
            EntityAspects.Add(entityAspect);
        }

        public string ToJson()
        {
            var payload = new JObject();

            var entitiesArray = new JArray();
            foreach (var item in EntityAspects)
            {
                var jEntity = EntityAndEntityAspectToJObject(item.Entity, item);
                entitiesArray.Add(jEntity);
            }

            payload.Add("entities", entitiesArray);
            payload.Add("saveOptions", JObject.FromObject(SaveOptions, JsonSerializer));

            return payload.ToString();
        }

        /// <summary>
        /// The schame we need to create has the entity aspect object as a property of the entity itself
        /// since this cannot be done with static types we only combine the two when creating the json
        /// </summary>
        public JObject EntityAndEntityAspectToJObject(object entity, EntityAspect entityAspect)
        {
            var jEntity = JObject.FromObject(entity, JsonSerializer);
            jEntity.Add("entityAspect", JObject.FromObject(entityAspect, JsonSerializer));
            return jEntity;
        }

    }

    public class EntityGeneratedKey
    {
        public string PropertyName { get; set; } = "Id";
        public string AutoGeneratedKeyType { get; set; } = "Identity";
    }


    public class EntityAspect
    {
        public string EntityTypeName { get; set; }
        public string DefaultResourceName { get; set; }
        public EntityState EntityState { get; set; }
        public Dictionary<string, object> OriginalValuesMap { get; set; } = new Dictionary<string, object>();
        public EntityGeneratedKey AutoGeneratedKey { get; set; }

        internal object Entity { get; }

        public EntityAspect(object entity, EntityState state)
        {
            Entity = entity;
            var type = entity.GetType();
            EntityTypeName = $"{type.Name}:#{type.Namespace}";
            DefaultResourceName = type.Name + "s";
            EntityState = state;

            AutoGeneratedKey = new EntityGeneratedKey();
        }

        /// <summary>
        /// Changes the value of the property belonging to the entity 
        /// and adds the old value to the original values map if this is the first change of that
        /// property
        /// </summary>
        public void ChangeValue(string prop, object value)
        {
            var originalVal = Entity.GetType().GetProperty(prop).GetValue(Entity);
            Entity.GetType().GetProperty(prop).SetValue(Entity, value, null);
            if (!OriginalValuesMap.ContainsKey(prop))
            {
                OriginalValuesMap[prop] = originalVal;
            }
        }
    }
}

